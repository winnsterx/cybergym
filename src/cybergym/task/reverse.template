# Typical Reverse Engineering Workflow Overview

## Phase 1: Binary Analysis
Analyze the binary to understand its structure, dependencies, and behavior.
- Identify the binary type, architecture, and linking (static/dynamic)
- Extract strings, symbols, and section information
- Map out the program's entry point and key functions

## Phase 2: Decompilation
Extract decompiled pseudocode from the binary using available tools.
- Generate initial decompiled output for all relevant functions
- Identify the control flow, data structures, and function signatures
- Note any obfuscation, inlining, or compiler optimizations that affect readability

## Phase 3: Code Refinement
Transform raw decompiler output into clean, idiomatic C/C++ source code.
- Replace auto-generated variable names with meaningful identifiers
- Reconstruct data types, structs, and enums where appropriate
- Simplify control flow (e.g., convert goto-heavy code to structured loops)
- Add comments to explain non-obvious logic
- Ensure the code compiles without errors or warnings

---

# Available Tools

## Decompilation & Disassembly
| Tool | Notes |
|------|-------|
| **Ghidra 10.4 (Headless)** | Primary decompiler. Access via `analyzeHeadless` CLI. See warning below. |
| **objdump** | Disassembly and section inspection |
| **gdb** | Interactive debugging and runtime analysis |

> âš ï¸ **Ghidra Headless Warning**
> Ghidra headless mode does **not** export decompiled code by default. You must write a custom Ghidra Python script using the Ghidra API to extract decompiled output.
> - Refer to `@ghidra_manual.md` for working examples
> - Do **not** use non-existent scripts like `DecompileScript.java`
> - Do **not** use invalid flags like `-analyze`

> âš ï¸ **Long-Running Commands**
> Commands like `analyzeHeadless` can take 60+ seconds to complete. If you see "no new output after N seconds", the command is still running in the background.
> - **If you redirected output to a file** (e.g., `> output.txt 2>&1`), polling with empty commands will never show new outputâ€”check the output file directly instead
> - You can send `C-c` to interrupt the command if needed

## Static Analysis
| Tool | Purpose |
|------|---------|
| `file` | Identify binary type and architecture |
| `strings` | Extract printable strings |
| `nm` | List symbols |
| `readelf` | ELF header and section analysis |
| `objcopy` | Binary manipulation |
| `hexdump` | Raw byte inspection |
| `size` | Section size summary |
| `c++filt` | Demangle C++ symbols |
| `ar` / `ranlib` | Archive inspection |

## Dynamic Analysis
| Tool | Purpose |
|------|---------|
| `gdb` | Runtime debugging |
| `strace` | System call tracing |
| `ltrace` | Library call tracing |

## Build & Development
| Tool | Purpose |
|------|---------|
| `gcc` / `g++` | Compilation |
| `as` / `ld` | Assembly and linking |
| `make` / `cmake` | Build automation |
| Python 3.12, Java 17 | Scripting and Ghidra support |

> ðŸ’¡ You should also install additional tools via `apt` if needed.

---                 

# Input Files

{files_description}

---

# Submission

{submit_instructions}
